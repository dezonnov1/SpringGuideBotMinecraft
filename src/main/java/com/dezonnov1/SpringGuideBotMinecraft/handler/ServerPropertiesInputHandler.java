package com.dezonnov1.SpringGuideBotMinecraft.handler;

import com.dezonnov1.SpringGuideBotMinecraft.entity.BotAction;
import com.dezonnov1.SpringGuideBotMinecraft.entity.BotState;
import com.dezonnov1.SpringGuideBotMinecraft.entity.ServerProperty;
import com.dezonnov1.SpringGuideBotMinecraft.entity.UserSession;
import com.dezonnov1.SpringGuideBotMinecraft.repository.ServerPropertyRepository;
import com.dezonnov1.SpringGuideBotMinecraft.service.BotInfoHolder;
import com.pengrad.telegrambot.model.Update;
import com.pengrad.telegrambot.request.BaseRequest;
import com.pengrad.telegrambot.request.SendDocument;
import com.pengrad.telegrambot.request.SendMessage;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

@Component
@RequiredArgsConstructor
public class ServerPropertiesInputHandler implements DialogHandler {

    private final ServerPropertyRepository propertyRepository;
    private final BotInfoHolder botInfoHolder;

    @Lazy
    private final StartHandler startHandler;

    private static final int MAX_LINE_LENGTH = 100;

    @Override
    public boolean isApplicable(BotState currentState, Update update) {
        return currentState == BotState.WAITING_FOR_SP_INPUT;
    }

    @Override
    public HandlerResult handle(UserSession session, Update update) {
        Long chatId = session.getChatId();
        List<BaseRequest<?, ?>> responses = new ArrayList<>();

        // 1. Логика отмены (тут у нас всё работало)
        if (update.callbackQuery() != null) {
            String data = update.callbackQuery().data();

            // Сравниваем с Enum CANCEL_INPUT
            if (BotAction.CANCEL_INPUT.getCallbackData().equals(data)) {
                responses.add(new SendMessage(chatId, "Ввод отменен. Возвращаюсь в главное меню."));
                responses.add(startHandler.getWelcomeMessage(chatId));

                return new HandlerResult(responses, BotState.MAIN_MENU);
            }
        }

        // === 2. ЛОГИКА ВВОДА ===
        if (update.message() != null && update.message().text() != null) {
            String versionInput = update.message().text().trim();
            List<ServerProperty> properties = propertyRepository.findAllByVersionName(versionInput);

            if (properties.isEmpty()) {
                SendMessage error = new SendMessage(chatId,
                        "Для версии " + versionInput + " у меня нет данных.\n" +
                                "Попробуйте, например: 1.16.5 или 1.20.1");
                return new HandlerResult(List.of(error), null);
            }

            StringBuilder sb = new StringBuilder();
            sb.append("# Minecraft server.properties generated by %s\n".formatted(botInfoHolder.getBotLink()));
            sb.append("# Для сервера версии: %s\n\n".formatted(versionInput));

            for (ServerProperty prop : properties) {
                appendFormattedComment(sb, prop.getDescription());
                if (prop.getRecommendation() != null && !prop.getRecommendation().isEmpty()) {
                    appendFormattedComment(sb, "Рекомендация: " + prop.getRecommendation());
                }
                sb.append(prop.getParameter())
                        .append("=")
                        .append(prop.getDefaultValue())
                        .append("\n\n");
            }

            byte[] fileBytes = sb.toString().getBytes(StandardCharsets.UTF_8);

            SendDocument doc = new SendDocument(chatId, fileBytes)
                    .fileName("server.properties")
                    .caption("Готово! Вот ваш файл настроек для версии " + versionInput);

            responses.add(doc);

            responses.add(startHandler.getWelcomeMessage(chatId));

            return new HandlerResult(responses, BotState.MAIN_MENU);
        }

        return new HandlerResult(
                List.of(new SendMessage(chatId, "Пожалуйста, напишите версию Minecraft текстом или нажмите 'Отмена'.")),
                null
        );
    }

    private void appendFormattedComment(StringBuilder sb, String text) {
        if (text == null || text.isBlank()) return;
        String[] lines = text.replace("\r", "").split("\n");
        for (String line : lines) {
            line = line.trim();
            if (line.isEmpty()) continue;
            if (line.length() <= MAX_LINE_LENGTH) {
                sb.append("# ").append(line).append("\n");
            } else {
                String[] words = line.split("\\s+");
                StringBuilder currentLine = new StringBuilder("# ");
                for (String word : words) {
                    if (currentLine.length() + word.length() + 1 > MAX_LINE_LENGTH) {
                        sb.append(currentLine).append("\n");
                        currentLine = new StringBuilder("# ").append(word);
                    } else {
                        if (currentLine.length() > 2) currentLine.append(" ");
                        currentLine.append(word);
                    }
                }
                sb.append(currentLine).append("\n");
            }
        }
    }
}