package com.dezonnov1.SpringGuideBotMinecraft.handler;

import com.dezonnov1.SpringGuideBotMinecraft.entity.BotState;
import com.dezonnov1.SpringGuideBotMinecraft.entity.ServerProperty;
import com.dezonnov1.SpringGuideBotMinecraft.entity.UserSession;
import com.dezonnov1.SpringGuideBotMinecraft.repository.ServerPropertyRepository;
import com.pengrad.telegrambot.model.Update;
import com.pengrad.telegrambot.request.SendDocument;
import com.pengrad.telegrambot.request.SendMessage;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.util.List;

@Component
@RequiredArgsConstructor
public class ServerPropertiesInputHandler implements DialogHandler {

    private final ServerPropertyRepository propertyRepository;
    private static final int MAX_LINE_LENGTH = 100; // Лимит символов

    @Override
    public boolean isApplicable(BotState currentState, Update update) {
        return currentState == BotState.WAITING_FOR_SP_INPUT && update.message() != null;
    }

    @Override
    public HandlerResult handle(UserSession session, Update update) {
        Long chatId = session.getChatId();

        // 1. Если пользователь прислал версию текстом
        if (update.message().text() != null) {
            String versionInput = update.message().text().trim();

            List<ServerProperty> properties = propertyRepository.findAllByVersionName(versionInput);

            if (properties.isEmpty()) {
                SendMessage error = new SendMessage(chatId,
                        "❌ Для версии " + versionInput + " у меня нет данных.\n" +
                                "Попробуйте, например: 1.16.5 или 1.20.1");
                return new HandlerResult(List.of(error), null);
            }

            // 2. Генерируем содержимое файла
            StringBuilder sb = new StringBuilder();
            sb.append("# Minecraft server.properties generated by t.me/guide_for_minecraft_bot\n");
            sb.append("# Для сервера версии: ").append(versionInput).append("\n");
            sb.append("# \n"); // Пустая строка-комментарий для отступа

            for (ServerProperty prop : properties) {
                // --- ИЗМЕНЕНИЕ НАЧАЛО: Используем метод форматирования ---

                // Обработка описания
                appendFormattedComment(sb, prop.getDescription());

                // Обработка рекомендации (если есть)
                if (prop.getRecommendation() != null && !prop.getRecommendation().isEmpty()) {
                    appendFormattedComment(sb, "Рекомендация: " + prop.getRecommendation());
                }

                // --- ИЗМЕНЕНИЕ КОНЕЦ ---

                // Сама настройка: key=value
                sb.append(prop.getParameter())
                        .append("=")
                        .append(prop.getDefaultValue())
                        .append("\n\n");
            }

            // 3. ПРЕВРАЩАЕМ ТЕКСТ В ФАЙЛ
            byte[] fileBytes = sb.toString().getBytes(StandardCharsets.UTF_8);

            // 4. Формируем документ
            SendDocument doc = new SendDocument(chatId, fileBytes)
                    .fileName("server.properties")
                    .caption("✅ Готово! Вот ваш файл настроек для версии " + versionInput);

            return new HandlerResult(List.of(doc), BotState.MAIN_MENU);
        }

        return new HandlerResult(
                List.of(new SendMessage(chatId, "Пожалуйста, напишите версию Minecraft (например 1.20.1).")),
                null
        );
    }

    /**
     * Метод для форматирования комментариев в файле.
     * 1. Разбивает текст по существующим \n
     * 2. Если строка длиннее MAX_LINE_LENGTH, переносит слова на новую строку
     * 3. Добавляет # перед каждой строкой
     */
    private void appendFormattedComment(StringBuilder sb, String text) {
        if (text == null || text.isBlank()) {
            return;
        }

        // Разбиваем исходный текст на строки (учитываем возможные переносы в БД)
        // replace("\r", "") нужен на случай Windows-style переносов
        String[] lines = text.replace("\r", "").split("\n");

        for (String line : lines) {
            line = line.trim();
            if (line.isEmpty()) continue;

            // Если строка влезает в лимит — просто пишем её
            if (line.length() <= MAX_LINE_LENGTH) {
                sb.append("# ").append(line).append("\n");
            } else {
                // Если не влезает — разбиваем по словам (Word Wrap)
                String[] words = line.split("\\s+"); // Разбиваем по пробелам
                StringBuilder currentLine = new StringBuilder("# ");

                for (String word : words) {
                    // Проверяем: длина текущей строки + пробел + слово
                    if (currentLine.length() + word.length() + 1 > MAX_LINE_LENGTH) {
                        // Если переполнили — сохраняем текущую строку в буфер и начинаем новую
                        sb.append(currentLine).append("\n");
                        currentLine = new StringBuilder("# ").append(word);
                    } else {
                        // Если влазит — добавляем пробел (если это не начало строки) и слово
                        if (currentLine.length() > 2) { // > 2, так как в начале уже есть "# "
                            currentLine.append(" ");
                        }
                        currentLine.append(word);
                    }
                }
                // Не забываем добавить остаток последней строки
                sb.append(currentLine).append("\n");
            }
        }
    }
}